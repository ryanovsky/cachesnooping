<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Cachesnooping : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Cachesnooping</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/ryanovsky/cachesnooping">View on GitHub</a>

          <h1 id="project_title">Cachesnooping</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/ryanovsky/cachesnooping/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/ryanovsky/cachesnooping/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="summary" class="anchor" href="#summary" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Summary</h3>

<p>We are going to implement a backend application for Contech that will simulate the MESI protocol with a variable number of cores 
in a processor, as well as transactional memory using the lazy optimistic scheme. We will then use our simulation to measure bus 
traffic and contention, as well as transactional memory commits and aborts.</p>

<h3>
<a id="background" class="anchor" href="#background" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Background</h3>

<p>There are several different implementations of cache coherence protocols, some of the foremost protocols are the MSI, 
MESI, and Dragon protocols. We will implement the MESI protocol, which is similar to the MSI, except for the added exclusive 
state which adds the benefit of decreased bus traffic.</p>

<p>We will use the lazy versioning scheme of transactional memory, which logs memory updates into a transaction write buffer.
The buffer is then flushed to memory upon a commit. In order to detect conflicts between multiple processors we will use 
optimistic detection.  Optimistic detection only checks for conflicts when a transaction attempts to commit.  When a conflict 
occurs, the committing transaction gets priority, while the other transaction must restart.</p>

<p>Our simulator will only look at the bus arbitration for an L1 cache.</p>

<h3>
<a id="the-challenge" class="anchor" href="#the-challenge" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Challenge</h3>

<p>We will need to simulate a variable core processor, where each core contains an L1 cache. For each core, we need to keep track
of the cache hits, cache misses, the number of times this core has contended for the bus, and the number of times this core has 
won the bus. We will also have to learn about the Contech framework, and the implementations of a task graph,  in order to use 
the resulting task graphs to simulate cache coherence.  Lastly we will implement a simulation of transactional memory, which 
will provide the added benefit of synchronization between caches.</p>

<h3>
<a id="resources" class="anchor" href="#resources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Resources</h3>

<p>We will be building off of the contech repository on github (https://github.com/bprail/contech).   We will create a new backend 
application in the contech/backend/ directory under cachecoherence/.  It will use Contech generated task graphs of parallel programs 
to analyze and simulate the cache interactions on our processor.</p>

<h3>
<a id="goals-and-deliverables" class="anchor" href="#goals-and-deliverables" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Goals and Deliverables</h3>

<p>By the end of the project, we should have analysis on cache performance using the MESI protocol on varying memory traces, as well 
as how the bus traffic changes as the number of cores increases. We will also have a simulation of transactional memory to create 
synchronization between processors and avoid race conditions.</p>

<h3>
<a id="platform-choice" class="anchor" href="#platform-choice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Platform Choice</h3>

<p>Seeing as we are simulating the processor, the machine we run on doesnâ€™t need any special hardware. We will use C++ to write 
our simulator and cache coherence implementation..</p>

<h3>
<a id="schedule" class="anchor" href="#schedule" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Schedule</h3>

<p>April 4 - 10 : simulate a single cache and processor that reads in Contech traces<br>
April 11 - 17 : implement MESI protocol<br>
April 18 - 24 : add transactional memory<br>
April 25 - May 1: Look at meaningful statistics and analyze<br>
May 2 - May 9: Create presentation</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Cachesnooping maintained by <a href="https://github.com/ryanovsky">ryanovsky</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
