{
  "name": "Cachesnooping",
  "tagline": "",
  "body": "### Summary\r\nWe are going to simulate MESI protocol with various number of caches and processors, in order to analyze useful statistics.\r\n\r\nWe are then going to implement transactional memory using the lazy optimistic scheme, to allow the user to have synchronization between caches.\r\nWe will compare bus traffic stats, including number of contenders and cache hits/misses/evictions\r\n\r\n### Background\r\nThere are several different implementations of cache coherence protocols, some of the foremost protocols are the MSI, MESI, and Dragon protocols. We will implement the MESI protocol, which is similar to the MSI, except for the added exclusive state which adds the benefit of decreased bus traffic.\r\n\r\nWe will use the lazy versioning scheme of transactional memory, which logs memory updates into a transaction write buffer.  The buffer is then flushed to memory upon a commit. In order to detect conflicts between multiple processors we will use optimistic detection.  Optimistic detection only checks for conflicts when a transaction attempts to commit.  When a conflict occurs, the committing transaction gets priority, while the other transaction must restart.\r\n\r\nOur simulator will only look at the bus arbitration for an L1 cache.\r\n\r\n### The Challenge\r\n We will need to simulate a variable core processor, where each core contains an L1 cache. For each core, we need to keep track of the cache hits, cache misses, the number of times this core has contended for the bus, and the number of times this core has won the bus. We will also have to learn how to use Contech in order to generate memory traces to test our simulations with.  Lastly we will implement a simulation of transactional memory, which will provide the added benefit of synchronization between caches.\r\n\r\n### Resources\r\nWe will be using the information presented in lecture slides to implement the MESI protocol as well as transactional memory.  \r\nWe will use the Contech to generate memory traces of parallel programs so analyze and simulate the cache interactions on our processor.\r\n\r\n### Goals and Deliverables\r\n By the end of the project, we should have analysis on cache snooping using the MESI protocol on varying memory traces, as well as how the bus traffic changes as the number of cores increases. We will also have a simulation of transactional memory to create synchronization between processors and avoid race conditions.\r\n\r\n###Platform Choice\r\nSeeing as we are simulating the processor, the machine we run on doesnâ€™t need any special hardware. We will use C++ to write our simulator and cache coherence implementation..\r\n\r\n###Schedule\r\nApril 4 - 10 : simulate a single cache and processor that reads in Contech traces    \r\nApril 11 - 17 : implement MESI protocol    \r\nApril 18 - 24 : add transactional memory    \r\nApril 25 - May 1: Look at meaningful statistics and analyze    \r\nMay 2 - May 9: Create presentation\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}